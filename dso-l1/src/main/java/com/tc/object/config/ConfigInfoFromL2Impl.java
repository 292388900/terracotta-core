/*
 * All content copyright Terracotta, Inc., unless otherwise indicated. All rights reserved.
 */
package com.tc.object.config;

import org.apache.commons.io.IOUtils;
import org.xml.sax.SAXParseException;

import com.tc.config.schema.L2ConfigForL1.L2Data;
import com.tc.config.schema.setup.L1ConfigurationSetupManager;
import com.tc.logging.CustomerLogging;
import com.tc.logging.TCLogger;
import com.tc.net.core.ConnectionInfo;
import com.tc.properties.TCPropertiesConsts;
import com.tc.properties.TCPropertiesImpl;
import com.tc.security.PwProvider;
import com.tc.util.concurrent.ThreadUtil;
import com.tc.util.io.ServerURL;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PushbackInputStream;

/*
 * Read the configuration from L2 via Servlet. It loops through L2 server list known to L1 until a successful
 * connection.
 */
public class ConfigInfoFromL2Impl implements ConfigInfoFromL2 {

  private static final TCLogger  logger                                       = CustomerLogging.getDSOGenericLogger();
  private static final TCLogger  consoleLogger                                = CustomerLogging.getConsoleLogger();
  private static final long      RECONNECT_WAIT_INTERVAL                      = TCPropertiesImpl
                                                                                  .getProperties()
                                                                                  .getLong(TCPropertiesConsts.L1_SOCKET_RECONNECT_WAIT_INTERVAL);
  private static final long      MIN_RETRY_INTERVAL_MILLS                     = 1000;

  public static final String     GROUP_INFO_SERVLET_PATH                      = "/groupinfo";
  public static final String     GROUPID_MAP_SERVLET_PATH                     = "/groupidmap";
  public static final String     L1_RECONNECT_PROPERTIES_FROML2_SERVELET_PATH = "/l1reconnectproperties";

  private final long             connectRetryInterval;
  private final ConnectionInfo[] connections;
  private final PwProvider       pwProvider;

  public ConfigInfoFromL2Impl(L1ConfigurationSetupManager configSetupManager) {
    this(configSetupManager, null);
  }

  public ConfigInfoFromL2Impl(L1ConfigurationSetupManager configSetupManager, PwProvider pwProvider) {
    this(getConnectionsFromL1Config(configSetupManager), pwProvider);
  }

  public ConfigInfoFromL2Impl(ConnectionInfo[] connections, PwProvider pwProvider) {
    this.connections = connections;
    this.pwProvider = pwProvider;

    long interval = RECONNECT_WAIT_INTERVAL;
    if (RECONNECT_WAIT_INTERVAL < MIN_RETRY_INTERVAL_MILLS) {
      logger.info("Setting config connect retry interval to " + MIN_RETRY_INTERVAL_MILLS + " ms");
      interval = MIN_RETRY_INTERVAL_MILLS;
    }
    connectRetryInterval = interval;
  }

  /*
   * Get L2 connection info from L1ConfigurationSetupManager. Made static to be called in constructor.
   * @param configSetupManager L1 configuration setup
   */
  private static ConnectionInfo[] getConnectionsFromL1Config(L1ConfigurationSetupManager configSetupManager) {
    L2Data[] l2s = null;
    // synchronized here as same issue of MNK-1984. ArrayIndexOutOfBoundsException in multi threaded environment due to
    // apache bug https://issues.apache.org/jira/browse/XMLBEANS-328
    synchronized (configSetupManager) {
      l2s = configSetupManager.l2Config().l2Data();
    }
    // clean groupID which is supported to get from L2.
    for (L2Data l2 : l2s) {
      l2.setGroupId(0);
    }
    ConnectionInfoConfig connectInfo = new ConnectionInfoConfig(l2s, configSetupManager.getSecurityInfo());
    return connectInfo.getConnectionInfos();
  }



  private <T> T getAndParseDocumentFromL2(String message, String httpPath,
                                          FactoryParser<T> factoryParser) {
    int tries = 0;
    InputStream in = null;
    while (true) {
      in = getPropertiesFromServerViaHttp(message, httpPath);
      try {
        try {
          return new ParseXmlObjectStream<T>().parse(message, in, factoryParser);
        } catch (SAXParseException e) {
          if (tries++ < 10) {
            logger.warn("Got an XML parse exception retrieving L1 reconnect properties. Retrying...");
            continue;
          } else {
            throw e;
          }
        }
      } catch (Exception e) {
        consoleLogger.error(e.getMessage());
        logger.error(e);
        throw new AssertionError(e);
      } finally {
        IOUtils.closeQuietly(in);
      }
    }
  }

  /*
   * Wrap a method to be called by ParseXmlObjectStream.parse().
   * @param <T> a class defined/generated by terracotta6.xsd, a factory method to parse InputStream into <T>.
   */
  interface FactoryParser<T> {
    T parse(InputStream in) throws Exception;
  }

  /*
   * Parse InputStream into an XmlObject document.
   * @param <T> an XmlObject document to be parsed out.
   */
  private static class ParseXmlObjectStream<T> {

    /*
     * Parse InputStream by parser according to the specified XmlObject type.
     * @param mesg used in logger to know which properties to be handled.
     * @param in InputStream from http servlet connection to L2.
     * @parser a factory method for specified type of XmlObject.
     * @return <T> XmlObject defined/generated by terracotta6.xsd.
     */
    public T parse(String mesg, InputStream in, FactoryParser<T> parser) throws Exception {
      PushbackInputStream pin = new PushbackInputStream(in, 100);
      byte[] prop = new byte[100];
      int propHeadReadLength = pin.read(prop);
      if (propHeadReadLength > 0) {
        pin.unread(prop, 0, propHeadReadLength);
      }

      try {
        return parser.parse(pin);
      } catch (Exception e) {
        if (propHeadReadLength > 0) {
          logger.error("Error parsing " + mesg + "  from server : " + new String(prop, 0, propHeadReadLength) + "...");
        }
        throw e;
      }
    }
  }

  /*
   * Looping through L2 list until a valid connection established or over MAX_CONNECT_TRIES.
   * @param message used only for logger.
   * @httpPathExtension path to the servlet.
   * @return InputStream to connected L2 servlet.
   */
  private InputStream getPropertiesFromServerViaHttp(String message, String httpPathExtension) {
    StringBuilder text = new StringBuilder("Can't connect to ");
    if (connections.length > 1) text.append("any of the servers [");
    else text.append("server [");

    for (int i = 0; i < connections.length; i++) {
      if (i > 0) text.append(", ");
      text.append(connections[i]);
    }
    text.append("].");

    boolean loggedInConsole = false;
    while (true) {
      InputStream in = getPropertiesFromL2Stream(message, httpPathExtension);
      if (in != null) { return in; }

      if (loggedInConsole == false) {
        consoleLogger.warn(text + "Retrying... \n");
        loggedInConsole = true;
      }
      if (connections.length > 1) {
        logger.warn(text + "Retrying... \n");
      }

      ThreadUtil.reallySleep(connectRetryInterval);
    }
  }

  /*
   * Open an InputStream via http servlet from one of L2s.
   */
  @SuppressWarnings("resource")
  private InputStream getPropertiesFromL2Stream(String message, String httpPathExtension) {
    InputStream propFromL2Stream;
    ServerURL theURL;
    for (int i = 0; i < connections.length; i++) {
      ConnectionInfo ci = connections[i];
      try {
        theURL = new ServerURL(ci.getHostname(), ci.getPort(), httpPathExtension, ci.getSecurityInfo());
        String text = "Trying to get " + message + " from " + theURL.toString();
        logger.info(text);
        propFromL2Stream = theURL.openStream(pwProvider);
        if (propFromL2Stream != null) {
          ByteArrayOutputStream baos = new ByteArrayOutputStream();
          try {
            IOUtils.copy(propFromL2Stream, baos);
          } finally {
            propFromL2Stream.close();
          }

          return new ByteArrayInputStream(baos.toByteArray());
        }
      } catch (IOException e) {
        if (i < connections.length - 1) {
          logger.warn("Can't connect to [" + ci + "]. Will retry next server.");
        } else {
          logger.warn("Can't connect to [" + ci + "].");
        }
      }
    }
    
    return null;
  }

}
